id = \x. \y: x. y -- since the types that ben lynn's site shows us aren't that useful sometimes, we'll use this to type check manually
arrow = \x y. pi a: x. y -- syntactic sugar arrows are not real and should be trusted
eq = \x y. pi z. (x->z)->(y->z) -- \x y. pi z. (x->z)->(y->z)

eqRefl = id (pi x. eq x x) (\x z. id (arrow x z))
arrowEquivToSyntaxArrow = id (pi x y. eq (arrow x y) (x->y)) (\x y. eqRefl (arrow x y)) -- ok we can trust them now

comp = \h i j. \f: (i->j). \g: (h->i). \a: h. f (g a)
--eqSymm = id (pi x y. (eq x y)->(eq y x)) (\x y. \e: eq x y. \z. ....)
eqTrans = id (pi w x y. (eq w x) -> (eq x y) -> (eq w y)) (\w x y. \ewx: eq w x. \exy: eq x y. \z. comp (w->z) (x->z) (y->z) (exy z) (ewx z))
-- BEN LYNNS COMPILER FAILS HERE

nat = pi x. (x->x)->(x->x)
zeroNat = id nat (\x. \y: (x->x). \z: x. z)
succNat = id (nat->nat) (\n: nat. \x. \y: (x->x). \z: x. y (n x y z))
